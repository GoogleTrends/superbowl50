<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta http-equiv="Content-Language" content="en" />
    <link href="css/bootstrap.min.css" rel="stylesheet">
    <script type="text/javascript" src="js/jquery.js"></script>
    <title>Superbowl</title>
</head>
<style>
.land {
    fill: lightgrey;
    opacity: .4;
    stroke: darkgrey;
    stroke-width: 1px;

}

.county-boundary {
    fill: none;
    stroke: #fff;
    stroke-width: .5px;
}

.arcs path {
	  /*stroke-width: 2px;*/
	  stroke: orange;
	  pointer-events: none;
      opacity: .6;
	  fill: none;
	}



</style>

<body>
    <div id="graphic"></div>
    <script type="text/javascript" src="js/d3.min.js"></script>
    <script type="text/javascript" src="js/topojson.v1.min.js"></script>
    <script src="cities.js"></script>

    <script>
    var width = 960,
        height = 500;

    var projection = d3.geo.albersUsa()
        .scale(1000)
        .translate([width / 2, height / 2]);

    var path = d3.geo.path()
        .projection(projection);

    var svg = d3.select("#graphic").append("svg")
        .attr("width", width)
        .attr("height", height)
        .call(responsivefy);
    
    d3.json("us.json", function(error, us) {
        if (error) throw error;

        svg.insert("path", ".graticule")
            .datum(topojson.feature(us, us.objects.land))
            .attr("class", "land")
            .attr("d", path);

        var arcs = svg.append("g")
                  .attr("class","arcs");

        arcs.selectAll("path")
         	.data(arcdata)
         	.enter()
         	.append("path")
         	.attr("d",function(d){
         		return lngLatToArc(d, 'sourceLocation', 'targetLocation', 15);
         	})
            .style("stroke-width", function(d,i){
            return arcdata[i].index/2;
           });

        svg.selectAll(".point")
           .data(arcdata)
           .enter()
           .append("circle")
           .attr("r", function(d,i){
            return arcdata[i].index;
           })
           .style("fill", "grey")
           .attr("transform", function(d,i) {
            return "translate(" + projection([arcdata[i].sourceLocation[0], arcdata[i].sourceLocation[1]]) + ")";
            });

        svg.selectAll("text")
           .data(arcdata)
           .enter()
           .append("text")
           .style("fill", "black")
           .attr("text-anchor","middle")
           .text(function(d,i){
            return arcdata[i].city;
           })
           .attr("transform", function(d,i) {
            return "translate(" + projection([arcdata[i].sourceLocation[0], (arcdata[i].sourceLocation[1] + .8)]) + ")";
            });

        svg.append("circle")
           .attr("r", 15)
           .style("fill", "grey")
           .attr("transform", function() {
            return "translate(" + projection([-122.4194155, 37.7749295]) + ")";
            });

	

    });

    function lngLatToArc(d, sourceName, targetName, bend){
		// set the bend
		bend = 1;
		// `d[sourceName]` and `d[targetname]` are arrays of `[lng, lat]`
		// Note, people often put these in lat then lng, but mathematically we want x then y which is `lng,lat`
		var sourceLngLat = d[sourceName],
				targetLngLat = d[targetName];
		if (targetLngLat && sourceLngLat) {
			var sourceXY = projection( sourceLngLat ),
					targetXY = projection( targetLngLat );
			var sourceX = sourceXY[0],
					sourceY = sourceXY[1];
			var targetX = targetXY[0],
					targetY = targetXY[1];
			var dx = targetX - sourceX,
					dy = targetY - sourceY,
					dr = Math.sqrt(dx * dx + dy * dy) * bend;
			// To avoid a whirlpool effect, make the bend direction consistent regardless of whether the source is east or west of the target
			var west_of_source = (targetX - sourceX) < 0;
			if (west_of_source) return "M" + targetX + "," + targetY + "A" + dr + "," + dr + " 0 0,1 " + sourceX + "," + sourceY;
			return "M" + sourceX + "," + sourceY + "A" + dr + "," + dr + " 0 0,1 " + targetX + "," + targetY;
			
		} else {
			return "M0,0,l0,0z";
		}
	}





    d3.select(self.frameElement).style("height", height + "px");

    function responsivefy(svg) {

        var container = d3.select(svg.node().parentNode),
            width = parseInt(svg.style("width")),
            height = parseInt(svg.style("height")),
            aspect = width / height;

        svg.attr("viewBox", "0 0 " + width + " " + height)
            .attr("perserveAspectRatio", "xMinYMid")
            .call(resize);

        d3.select(window).on("resize." + container.attr("#graphic"), resize);

        function resize() {
            var targetWidth = parseInt(container.style("width"));
            svg.attr("width", targetWidth);
            svg.attr("height", Math.round(targetWidth / aspect));
        }
    };

    



    </script>
